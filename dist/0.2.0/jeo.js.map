{"version":3,"sources":["jeo.js"],"names":["e","t","n","r","s","o","u","a","require","i","Error","f","exports","call","length",1,"module","global","name","factory","define","amd","eval","mix","to","from","undefined","arguments","Object_keys","forEach","key","assert","condition","message","requires","extractDependencies","descriptor","toBeDefined","not","toBeNull","constructor","hasOwnProperty","constructorArgumentCount","hasRequires","requiresSetting","Array","isArray","dependencyCount","JSON","stringify","dependency","isTrait","extractTraits","hasTraits","traits","is","extractMain","hasMain","main","Required","isRequired","object","extractPublicMethods","hasPublicMethods","publicMethods","item","extractPrivateMethods","hasPrivateMethods","privateMethods","storeMetaData","metaData","givenEvidence","secretEvidence","retrieveMetaData","expando","resolveDescriptor","resolver","projection","Object_create","result","publicKeyMap","member","hasRule","rule","makeTrait","resolve","create","createToplevelInstanceFactory","Object_freeze","makeHash","publicMembers","hash","sort","join","closeOverInstance","instance","config","substitute","filter","tt","trait","substituteHash","use","hashOfT","privateMembers","dependencies","map","dep","createInstance","privateContext","apply","memberIsRequired","fn","instanceHasMemberWithSameName","instanceMemberWithSameNameIsRequired","instanceMemberWithSameNameIsImplementation","concat","applyStatefulTrait","_x","_arguments","_again","args","_extractDependencies","_extractTraits","_extractMain","_extractPublicMethods","_extractPrivateMethods","Util","public","private","slice","arg","currentConfig","Object","freeze","keys","requiresExtensions","extension","thingy","ok","Math","round","random","log","console","for","required"],"mappings":"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","file":"jeo.js","sourcesContent":["/*! jeo v0.2.0 (c) 2015 Martin Feineis, MIT license (https://www.github.com/mfeineis/jeo) */\r\n/*jshint esnext:true, maxlen:80 */\r\n/*global define,module */\r\n(function (global, name, factory) {\r\n    'use strict';\r\n\r\n    if (typeof define !== 'undefined' && define.amd) {\r\n        // AMD\r\n        define([], factory);\r\n    }\r\n    else if (typeof module !== 'undefined') {\r\n        // CommonJS\r\n        module.exports = factory();\r\n    }\r\n    else {\r\n        // No modules\r\n        global[name] = factory();\r\n    }\r\n\r\n}((0, eval)('this'), 'jeo', () => {\r\n    'use strict';\r\n\r\n    const Object_create = Object.create;\r\n    const Object_freeze = Object.freeze;\r\n    const Object_keys = Object.keys;\r\n    const hasOwnProperty = {}.hasOwnProperty;\r\n\r\n    function mix(to, from = {}) {\r\n        \r\n        Object_keys(from).forEach(key => {\r\n            to[key] = from[key];\r\n        });\r\n\r\n        return to;\r\n    }\r\n\r\n    function assert(condition, message = 'An assertion failed.') {\r\n        if (!condition) {\r\n            throw new Error(message);\r\n        }\r\n    }\r\n\r\n    // Used to check preconditions\r\n    function requires(\r\n        condition, \r\n        message = 'A precondition has been violated.') {\r\n        if (!condition) {\r\n            throw new Error(message);\r\n        }\r\n    }\r\n    requires.not = {};\r\n\r\n    var requiresExtensions = {\r\n        toBeDefined(object) {\r\n            return typeof object !== 'undefined';\r\n        },\r\n        toBeNull(object) {\r\n            return object === null;\r\n        }\r\n    };\r\n\r\n    // Putting the extensions and their inverses onto the\r\n    // requires function\r\n    Object_keys(requiresExtensions).forEach(key => {\r\n\r\n        requires[key] = (function (extension) {\r\n            return function (thingy, message) {\r\n                const ok = extension(...arguments);\r\n                requires(ok, message);\r\n            };\r\n        }(requiresExtensions[key]));\r\n\r\n        requires.not[key] = (function (extension) {\r\n            return function (thingy, message) {\r\n                const ok = !extension(...arguments);\r\n                requires(ok, message);\r\n            };\r\n        }(requiresExtensions[key]));\r\n\r\n    });\r\n\r\n    function extractDependencies(descriptor) {\r\n        requires.toBeDefined(descriptor, 'No descriptor specified.');\r\n        requires.not.toBeNull(descriptor, 'A descriptor can not be null.');\r\n\r\n        const constructor = hasOwnProperty.call(descriptor, 'constructor') \r\n            ? descriptor.constructor\r\n            : function () {};\r\n        const constructorArgumentCount = constructor.length;\r\n\r\n        if (typeof constructor !== 'function') {\r\n            throw new Error('\"constructor\" must be a function.');\r\n        }\r\n\r\n        const hasRequires = hasOwnProperty.call(descriptor, 'requires');\r\n        const requiresSetting = hasRequires\r\n            ? (Array.isArray(descriptor.requires) \r\n                ? descriptor.requires\r\n                : [descriptor.requires])\r\n            : [];\r\n        const dependencyCount = requiresSetting.length;\r\n\r\n        if (constructorArgumentCount === 0 && dependencyCount > 0) {\r\n            throw new Error('\"requires\" is not allowed to provide ' +\r\n                    'dependencies when the constructor doesn\\'t require any');\r\n        }\r\n\r\n        if (constructorArgumentCount !== dependencyCount) {\r\n            throw new Error('\"requires\" has to provide the same amount of ' +\r\n                    'dependencies that the constructor declares (' + \r\n                        JSON.stringify(descriptor) + ')');\r\n        }\r\n\r\n        requiresSetting.forEach(dependency => {\r\n           if (!isTrait(dependency)) {\r\n               throw new Error('\"' + JSON.stringify(dependency) +'\" is not ' +\r\n                   'a valid trait');\r\n           } \r\n        });\r\n\r\n        return {\r\n            constructor: constructor,\r\n            requires: requiresSetting\r\n        };\r\n    }\r\n\r\n    function extractTraits(descriptor) {\r\n        const hasTraits = hasOwnProperty.call(descriptor, 'is');\r\n        const traits = hasTraits\r\n            ? (Array.isArray(descriptor.is)\r\n                ? descriptor.is\r\n                : [descriptor.is])\r\n            : [];\r\n\r\n        traits.forEach(t => {\r\n            if (!isTrait(t)) {\r\n                throw new Error('\"' + JSON.stringify(t) + '\" is not ' +\r\n                    'a valid trait');\r\n            }\r\n        });\r\n\r\n        return {\r\n            traits: traits\r\n        };\r\n    }\r\n\r\n    function extractMain(descriptor) {\r\n        const hasMain = hasOwnProperty.call(descriptor, 'main');\r\n        const main = hasMain\r\n            ? descriptor.main\r\n            : function () {};\r\n\r\n        if (typeof main !== 'function') {\r\n            throw new Error('\"main\", if provided has to be a function.');\r\n        }\r\n\r\n        return {\r\n            main: main\r\n        };\r\n    }\r\n\r\n    function Required() {}\r\n\r\n    function isRequired(object) {\r\n        return object instanceof Required;\r\n    }\r\n\r\n    function extractPublicMethods(descriptor) {\r\n        const hasPublicMethods = hasOwnProperty.call(descriptor, 'public');\r\n        const publicMethods = hasPublicMethods\r\n            ? descriptor.public\r\n            : {};\r\n\r\n        if (typeof publicMethods !== 'object') {\r\n            throw new Error('\"public\" has to be an object.');\r\n        }\r\n\r\n        Object_keys(publicMethods).forEach(name => {\r\n            const item = publicMethods[name];\r\n\r\n            if (!isRequired(item) && typeof item !== 'function') {\r\n                throw new Error('\"public\" can only contain functions or ' +\r\n                    ' \"required\" declarations (' +\r\n                    JSON.stringify(publicMethods) + ')');\r\n            }\r\n        });\r\n\r\n        return {\r\n            publicMethods: publicMethods\r\n        };\r\n    }\r\n\r\n    function extractPrivateMethods(descriptor) {\r\n        const hasPrivateMethods = hasOwnProperty.call(descriptor, 'private');\r\n        const privateMethods = hasPrivateMethods\r\n            ? descriptor.private\r\n            : {};\r\n\r\n        if (typeof privateMethods !== 'object') {\r\n            throw new Error('\"private\" has to be an object.');\r\n        }\r\n\r\n        Object_keys(privateMethods).forEach(name => {\r\n            if (typeof privateMethods[name] !== 'function') {\r\n                throw new Error('\"private\" can only contain functions (' +\r\n                    JSON.stringify(privateMethods) + ')');\r\n            }\r\n        });\r\n\r\n        return {\r\n            privateMethods: privateMethods\r\n        };\r\n    }\r\n\r\n    // Our expando property being used to store trait meta data\r\n    const expando = '__jeo_trait' + Math.round(Math.random() * 1000000000);\r\n\r\n    // This is a private key for securing our meta data against manipulation\r\n    const secretEvidence = { isTrait: true };\r\n\r\n    function storeMetaData(metaData) {\r\n        return function checkEvidenceValid(givenEvidence) {\r\n            if (givenEvidence === secretEvidence) {\r\n                return metaData;\r\n            }\r\n            else {\r\n                return undefined;\r\n            }\r\n        };\r\n    }\r\n\r\n    function retrieveMetaData(t) {\r\n        if (typeof t[expando] === 'function') {\r\n            return t[expando](secretEvidence);\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    function isTrait(object) {\r\n        if (typeof object[expando] === 'function') {\r\n            return !!retrieveMetaData(object);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function resolveDescriptor(descriptor, resolver) {\r\n        const projection = Object_create(descriptor);\r\n        const result = projection.public = {};\r\n        const publicKeyMap = {};\r\n\r\n        Object_keys(descriptor.public)\r\n            .forEach(name => {\r\n                publicKeyMap[name] = true;\r\n\r\n                const member = descriptor.public[name];\r\n\r\n                const hasRule = hasOwnProperty.call(resolver, name);\r\n                const rule = resolver[name];\r\n                \r\n                if (hasRule) {\r\n                    if (isRequired(member)) {\r\n                        throw new Error('Can not resolve required ' +\r\n                            'member \"' + name + '\".');\r\n                    }\r\n\r\n                    if (rule === null) {\r\n                        // Hide\r\n                        return;\r\n                    }\r\n\r\n                    if (typeof rule === 'string') {\r\n                        // Rename\r\n                        result[rule] = member;\r\n                    }\r\n                }\r\n                else {\r\n                    // Copy\r\n                    result[name] = member;\r\n                }\r\n            });\r\n\r\n        Object_keys(resolver).forEach(name => {\r\n            if (!hasOwnProperty.call(publicKeyMap, name)) {\r\n                throw new Error('\"' + name + '\" can not be resolved ' +\r\n                    'because it is not a public method on ' + \r\n                    JSON.stringify(descriptor));\r\n            }\r\n        });\r\n\r\n        return projection;\r\n    }\r\n\r\n    function makeTrait(descriptor) {\r\n\r\n        const t = {\r\n            resolve(resolver) {\r\n                return makeTrait(resolveDescriptor(descriptor, resolver));\r\n            }\r\n        };\r\n        t.create = createToplevelInstanceFactory(t);\r\n        t[expando] = storeMetaData(descriptor);\r\n\r\n        return Object_freeze(t);\r\n    }\r\n\r\n    function makeHash(t) {\r\n        const publicMembers = retrieveMetaData(t).public;\r\n        let hash = Object_keys(publicMembers);\r\n        hash.sort();\r\n        return hash.join('#');\r\n    }\r\n\r\n    function closeOverInstance(instance, config) {\r\n        return function applyStatefulTrait(t) {\r\n            let substitute = config.for.filter(tt => tt.trait === t)[0];\r\n            if (substitute) {\r\n                let substituteHash = makeHash(substitute.use);\r\n                let hashOfT = makeHash(t);\r\n\r\n                if (hashOfT !== substituteHash) {\r\n                    throw new Error('Substiute hash \"' + substituteHash + \r\n                        '\" does not match the hash \"' + hashOfT + '\" of ' +\r\n                        'the trait to be substituted');\r\n                }\r\n                t = substitute.use;\r\n            }\r\n\r\n            const descriptor = retrieveMetaData(t);\r\n            const publicMembers = descriptor.public;\r\n            const privateMembers = descriptor.private;\r\n            const dependencies = descriptor.requires\r\n                .map(dep => createInstance(dep, config));\r\n\r\n            const privateContext = {};\r\n            \r\n            descriptor.constructor.apply(privateContext, dependencies);\r\n\r\n            Object_keys(privateMembers)\r\n                .forEach(name => {\r\n                    const member = privateMembers[name];\r\n\r\n                    if (isRequired(member)) {\r\n                        throw new Error('Private members can not be ' +\r\n                            'required');\r\n                    }\r\n\r\n                    if (hasOwnProperty.call(privateContext, name)) {\r\n                        throw new Error('Can not overwrite member \"' +\r\n                            name + '\" which has previously been defined');\r\n                    }\r\n\r\n                    privateContext[name] = function () {\r\n                        return member.apply(privateContext, arguments);\r\n                    };\r\n                });\r\n\r\n            Object_keys(publicMembers)\r\n                .forEach(name => {\r\n                    if (hasOwnProperty.call(privateContext, name)) {\r\n                        throw new Error('Can not overwrite member \"' +\r\n                            name + '\" which has previously been defined');\r\n                    }\r\n\r\n                    const member = publicMembers[name];\r\n                    const memberIsRequired = isRequired(member);\r\n                    const fn = function () {\r\n                        return member.apply(privateContext, arguments);\r\n                    };\r\n\r\n                    const instanceHasMemberWithSameName = \r\n                        hasOwnProperty.call(instance, name);\r\n\r\n                    const instanceMemberWithSameNameIsRequired =\r\n                        instanceHasMemberWithSameName &&\r\n                            isRequired(instance[name]);\r\n\r\n                    const instanceMemberWithSameNameIsImplementation =\r\n                        instanceHasMemberWithSameName &&\r\n                            !isRequired(instance[name]);\r\n\r\n                    if (memberIsRequired && \r\n                        instanceMemberWithSameNameIsRequired) {\r\n                        // Do nothing, both are required so we\r\n                        // wait for an actual implementation\r\n                    }\r\n                    else if (memberIsRequired &&\r\n                            instanceMemberWithSameNameIsImplementation) {\r\n                        // Do nothing, the implementation is already\r\n                        // attached to the instance\r\n                    }\r\n                    else if (memberIsRequired && \r\n                            !instanceHasMemberWithSameName) {\r\n                        // This declares a new required member and\r\n                        // we still wait for the implementation\r\n                        instance[name] = member;\r\n                    }\r\n                    else if (!memberIsRequired &&\r\n                            (instanceMemberWithSameNameIsRequired ||\r\n                             !instanceHasMemberWithSameName)) {\r\n                        // Overwrite the required statement with the\r\n                        // specified implementation\r\n                        privateContext[name] = fn;\r\n                        instance[name] = fn;\r\n                    }\r\n                    else {\r\n                        throw new Error('Unknown composition pattern');\r\n                    }\r\n                });\r\n        };\r\n    }\r\n\r\n    function createInstance(t, config) {\r\n        if (!isTrait(t)) {\r\n            throw new Error('The argument \"' + JSON.stringify(t) + '\" is ' +\r\n                'not a trait and therefore can not be instantiated.');\r\n        }\r\n\r\n        const descriptor = retrieveMetaData(t);\r\n        let instance = {};\r\n        let traits = [t].concat(descriptor.is);\r\n\r\n        const applyStatefulTrait = closeOverInstance(instance, config);\r\n        traits.forEach(applyStatefulTrait);\r\n\r\n        Object_keys(instance).forEach(name => {\r\n            const member = instance[name];\r\n\r\n            if (isRequired(member)) {\r\n                throw new Error('Can not instantiate incomplete ' +\r\n                    'trait. The member \"' + name + \r\n                    '\" is still required.');\r\n            }\r\n        });\r\n\r\n        return instance;\r\n    }\r\n\r\n    // The main entry point for our library\r\n    function trait(descriptor) {\r\n        if (arguments.length > 1) {\r\n            const args = [].slice.call(arguments).map(arg => {\r\n                if (!arg) {\r\n                    throw new Error('A top level argument can not be falsy');\r\n                }\r\n\r\n                if (!isTrait(arg)) {\r\n                    return trait({ public: arg });\r\n                }\r\n                else {\r\n                    return arg;\r\n                }\r\n            });\r\n            return trait({ is: args });\r\n        }\r\n\r\n        if (typeof descriptor === 'function') {\r\n            descriptor = descriptor(createInstance(trait.Util, trait.config));\r\n        }\r\n\r\n        let { constructor, requires } = extractDependencies(descriptor);\r\n        let { traits } = extractTraits(descriptor);\r\n        let { main } = extractMain(descriptor);\r\n        let { publicMethods } = extractPublicMethods(descriptor);\r\n        let { privateMethods } = extractPrivateMethods(descriptor);\r\n\r\n        return makeTrait({\r\n            is: traits,\r\n            requires: requires,\r\n            constructor: constructor,\r\n            main: main,\r\n            public: publicMethods,\r\n            private: privateMethods\r\n        });\r\n    }\r\n\r\n    function createToplevelInstanceFactory(t) {\r\n        return function createToplevelInstance(config = {}) {\r\n            const currentConfig = mix(trait.config, config);\r\n\r\n            currentConfig.for.forEach(item => {\r\n                if (!isTrait(item.trait)) {\r\n                    throw new Error('Invalid configured dependency');\r\n                }\r\n                if (!isTrait(item.use)) {\r\n                    throw new Error('Invalid substituted dependency ' +\r\n                        'configured');\r\n                }\r\n            });\r\n\r\n            return createInstance(t, currentConfig);\r\n        };\r\n    }\r\n\r\n    return {\r\n        trait: Object_freeze(mix(trait, {\r\n            Util: trait({\r\n                public: {\r\n                    assert: assert,\r\n                    log() { console.log(...arguments); },\r\n                    mix: mix,\r\n                    requires: requires\r\n                }\r\n            }),\r\n            config: { for: [] },\r\n            isTrait: isTrait,\r\n            required: Object_freeze(new Required())\r\n        }))\r\n    };\r\n}));\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"sourceRoot":"/source/"}