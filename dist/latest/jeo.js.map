{"version":3,"sources":["jeo.js"],"names":["e","t","n","r","s","o","u","a","require","i","Error","f","exports","call","length",1,"module","global","name","factory","define","amd","eval","mix","to","from","undefined","arguments","Object_keys","forEach","key","requires","condition","message","extractDependencies","descriptor","toBeDefined","not","toBeNull","constructor","hasOwnProperty","constructorArgumentCount","hasRequires","requiresSetting","Array","isArray","dependencyCount","JSON","stringify","dependency","isTrait","extractTraits","hasTraits","traits","extractMain","hasMain","main","Required","isRequired","object","extractPublicMethods","hasPublicMethods","publicMethods","item","extractPrivateMethods","hasPrivateMethods","privateMethods","storeMetaData","metaData","givenEvidence","secretEvidence","retrieveMetaData","expando","resolveDescriptor","resolver","projection","Object_create","result","publicKeyMap","member","hasRule","rule","makeTrait","Object_defineProperty","enumerable","value","Object_freeze","closeOverInstance","instance","config","publicMembers","privateMembers","dependencies","map","dep","createInstance","privateContext","apply","memberIsRequired","fn","instanceHasMemberWithSameName","instanceMemberWithSameNameIsRequired","instanceMemberWithSameNameIsImplementation","concat","applyStatefulTrait","trait","Util","_extractDependencies","_extractTraits","_extractMain","_extractPublicMethods","_extractPrivateMethods","public","private","Object","create","defineProperty","freeze","keys","requiresExtensions","extension","thingy","ok","Math","round","random","log","console","required"],"mappings":"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","file":"jeo.js","sourcesContent":["/*! jeo v0.1.0 (c) 2015 Martin Feineis, MIT license (https://www.github.com/mfeineis/jeo) */\r\n/*jshint esnext:true, maxlen:80 */\r\n/*global define,module */\r\n(function (global, name, factory) {\r\n    'use strict';\r\n\r\n    if (typeof define !== 'undefined' && define.amd) {\r\n        // AMD\r\n        define([], factory);\r\n    }\r\n    else if (typeof module !== 'undefined') {\r\n        // CommonJS\r\n        module.exports = factory();\r\n    }\r\n    else {\r\n        // No modules\r\n        global[name] = factory();\r\n    }\r\n\r\n}((0, eval)('this'), 'Jeo', () => {\r\n    'use strict';\r\n\r\n    const Object_create = Object.create;\r\n    const Object_defineProperty = Object.defineProperty;\r\n    const Object_freeze = Object.freeze;\r\n    const Object_keys = Object.keys;\r\n    const hasOwnProperty = {}.hasOwnProperty;\r\n\r\n    function mix(to, from = {}) {\r\n        Object_keys(from).forEach(key => {\r\n            to[key] = from[key];\r\n        });\r\n        return to;\r\n    }\r\n\r\n    function assert(condition, message = 'An assertion failed.') {\r\n        if (!condition) {\r\n            throw new Error(message);\r\n        }\r\n    }\r\n\r\n    // Used to check preconditions\r\n    function requires(\r\n        condition, \r\n        message = 'A precondition has been violated.') {\r\n        if (!condition) {\r\n            throw new Error(message);\r\n        }\r\n    }\r\n    requires.not = {};\r\n\r\n    var requiresExtensions = {\r\n        toBeDefined(object) {\r\n            return typeof object !== 'undefined';\r\n        },\r\n        toBeNull(object) {\r\n            return object === null;\r\n        }\r\n    };\r\n\r\n    // Putting the extensions and their inverses onto the\r\n    // requires function\r\n    Object_keys(requiresExtensions).forEach(key => {\r\n\r\n        requires[key] = (function (extension) {\r\n            return function (thingy, message) {\r\n                const ok = extension(...arguments);\r\n                requires(ok, message);\r\n            };\r\n        }(requiresExtensions[key]));\r\n\r\n        requires.not[key] = (function (extension) {\r\n            return function (thingy, message) {\r\n                const ok = !extension(...arguments);\r\n                requires(ok, message);\r\n            };\r\n        }(requiresExtensions[key]));\r\n\r\n    });\r\n\r\n    function extractDependencies(descriptor) {\r\n        requires.toBeDefined(descriptor, 'No descriptor specified.');\r\n        requires.not.toBeNull(descriptor, 'A descriptor can not be null.');\r\n\r\n        const constructor = hasOwnProperty.call(descriptor, 'constructor') \r\n            ? descriptor.constructor\r\n            : function () {};\r\n        const constructorArgumentCount = constructor.length;\r\n\r\n        if (typeof constructor !== 'function') {\r\n            throw new Error('\"constructor\" must be a function.');\r\n        }\r\n\r\n        const hasRequires = hasOwnProperty.call(descriptor, 'requires');\r\n        const requiresSetting = hasRequires\r\n            ? (Array.isArray(descriptor.requires) \r\n                ? descriptor.requires\r\n                : [descriptor.requires])\r\n            : [];\r\n        const dependencyCount = requiresSetting.length;\r\n\r\n        if (constructorArgumentCount === 0 && dependencyCount > 0) {\r\n            throw new Error('\"requires\" is not allowed to provide ' +\r\n                    'dependencies when the constructor doesn\\'t require any');\r\n        }\r\n\r\n        if (constructorArgumentCount !== dependencyCount) {\r\n            throw new Error('\"requires\" has to provide the same amount of ' +\r\n                    'dependencies that the constructor declares (' + \r\n                        JSON.stringify(descriptor) + ')');\r\n        }\r\n\r\n        requiresSetting.forEach(dependency => {\r\n           if (!isTrait(dependency)) {\r\n               throw new Error('\"' + JSON.stringify(dependency) +'\" is not ' +\r\n                   'a valid trait');\r\n           } \r\n        });\r\n\r\n        return {\r\n            constructor: constructor,\r\n            requires: requiresSetting\r\n        };\r\n    }\r\n\r\n    function extractTraits(descriptor) {\r\n        const hasTraits = hasOwnProperty.call(descriptor, 'traits');\r\n        const traits = hasTraits\r\n            ? (Array.isArray(descriptor.traits)\r\n                ? descriptor.traits\r\n                : [descriptor.traits])\r\n            : [];\r\n\r\n        traits.forEach(t => {\r\n            if (!isTrait(t)) {\r\n                throw new Error('\"' + JSON.stringify(t) + '\" is not ' +\r\n                    'a valid trait');\r\n            }\r\n        });\r\n\r\n        return {\r\n            traits: traits\r\n        };\r\n    }\r\n\r\n    function extractMain(descriptor) {\r\n        const hasMain = hasOwnProperty.call(descriptor, 'main');\r\n        const main = hasMain\r\n            ? descriptor.main\r\n            : function () {};\r\n\r\n        if (typeof main !== 'function') {\r\n            throw new Error('\"main\", if provided has to be a function.');\r\n        }\r\n\r\n        return {\r\n            main: main\r\n        };\r\n    }\r\n\r\n    function Required() {}\r\n\r\n    function isRequired(object) {\r\n        return object instanceof Required;\r\n    }\r\n\r\n    function extractPublicMethods(descriptor) {\r\n        const hasPublicMethods = hasOwnProperty.call(descriptor, 'public');\r\n        const publicMethods = hasPublicMethods\r\n            ? descriptor.public\r\n            : {};\r\n\r\n        if (typeof publicMethods !== 'object') {\r\n            throw new Error('\"public\" has to be an object.');\r\n        }\r\n\r\n        Object_keys(publicMethods).forEach(name => {\r\n            const item = publicMethods[name];\r\n\r\n            if (!isRequired(item) && typeof item !== 'function') {\r\n                throw new Error('\"public\" can only contain functions or ' +\r\n                    ' \"required\" declarations (' +\r\n                    JSON.stringify(publicMethods) + ')');\r\n            }\r\n        });\r\n\r\n        return {\r\n            publicMethods: publicMethods\r\n        };\r\n    }\r\n\r\n    function extractPrivateMethods(descriptor) {\r\n        const hasPrivateMethods = hasOwnProperty.call(descriptor, 'private');\r\n        const privateMethods = hasPrivateMethods\r\n            ? descriptor.private\r\n            : {};\r\n\r\n        if (typeof privateMethods !== 'object') {\r\n            throw new Error('\"private\" has to be an object.');\r\n        }\r\n\r\n        Object_keys(privateMethods).forEach(name => {\r\n            if (typeof privateMethods[name] !== 'function') {\r\n                throw new Error('\"private\" can only contain functions (' +\r\n                    JSON.stringify(privateMethods) + ')');\r\n            }\r\n        });\r\n\r\n        return {\r\n            privateMethods: privateMethods\r\n        };\r\n    }\r\n\r\n    // Our expando property being used to store trait meta data\r\n    const expando = '__jeo_trait' + Math.round(Math.random() * 1000000000);\r\n\r\n    // This is a private key for securing our meta data against manipulation\r\n    const secretEvidence = { isTrait: true };\r\n\r\n    function storeMetaData(metaData) {\r\n        return function checkEvidenceValid(givenEvidence) {\r\n            if (givenEvidence === secretEvidence) {\r\n                return metaData;\r\n            }\r\n            else {\r\n                return undefined;\r\n            }\r\n        };\r\n    }\r\n\r\n    function retrieveMetaData(t) {\r\n        if (typeof t[expando] === 'function') {\r\n            return t[expando](secretEvidence);\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    function isTrait(object) {\r\n        if (typeof object[expando] === 'function') {\r\n            return !!retrieveMetaData(object);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function resolveDescriptor(descriptor, resolver) {\r\n        const projection = Object_create(descriptor);\r\n        const result = projection.public = {};\r\n        const publicKeyMap = {};\r\n\r\n        Object_keys(descriptor.public)\r\n            .forEach(name => {\r\n                publicKeyMap[name] = true;\r\n\r\n                const member = descriptor.public[name];\r\n\r\n                const hasRule = hasOwnProperty.call(resolver, name);\r\n                const rule = resolver[name];\r\n                \r\n                if (hasRule) {\r\n                    if (isRequired(member)) {\r\n                        throw new Error('Can not resolve required ' +\r\n                            'member \"' + name + '\".');\r\n                    }\r\n\r\n                    if (rule === null) {\r\n                        // Hide\r\n                        return;\r\n                    }\r\n\r\n                    if (typeof rule === 'string') {\r\n                        // Rename\r\n                        result[rule] = member;\r\n                    }\r\n                }\r\n                else {\r\n                    // Copy\r\n                    result[name] = member;\r\n                }\r\n            });\r\n\r\n        Object_keys(resolver).forEach(name => {\r\n            if (!hasOwnProperty.call(publicKeyMap, name)) {\r\n                throw new Error('\"' + name + '\" can not be resolved ' +\r\n                    'because it is not a public method on ' + \r\n                    JSON.stringify(descriptor));\r\n            }\r\n        });\r\n\r\n        return projection;\r\n    }\r\n\r\n    function makeTrait(descriptor) {\r\n        const t = {};\r\n\r\n        Object_defineProperty(t, 'resolve', {\r\n            enumerable: true,\r\n            value: function resolve(resolver) {\r\n                return makeTrait(resolveDescriptor(descriptor, resolver));\r\n            }\r\n        });\r\n\r\n        Object_defineProperty(t, expando, {\r\n            //configurable: false,\r\n            //enumerable: false,\r\n            value: storeMetaData(descriptor),\r\n            //writable: false\r\n        });\r\n\r\n        return Object_freeze(t);\r\n    }\r\n\r\n    function closeOverInstance(instance, config) {\r\n        return function applyStatefulTrait(t) {\r\n            const descriptor = retrieveMetaData(t);\r\n            const publicMembers = descriptor.public;\r\n            const privateMembers = descriptor.private;\r\n            const dependencies = descriptor.requires\r\n                .map(dep => createInstance(dep, config));\r\n\r\n            const privateContext = {};\r\n            \r\n            descriptor.constructor.apply(privateContext, dependencies);\r\n\r\n            Object_keys(privateMembers)\r\n                .forEach(name => {\r\n                    const member = privateMembers[name];\r\n\r\n                    if (isRequired(member)) {\r\n                        throw new Error('Private members can not be ' +\r\n                            'required');\r\n                    }\r\n\r\n                    if (hasOwnProperty.call(privateContext, name)) {\r\n                        throw new Error('Can not overwrite member \"' +\r\n                            name + '\" which has previously been defined');\r\n                    }\r\n\r\n                    privateContext[name] = function () {\r\n                        return member.apply(privateContext, arguments);\r\n                    };\r\n                });\r\n\r\n            Object_keys(publicMembers)\r\n                .forEach(name => {\r\n                    if (hasOwnProperty.call(privateContext, name)) {\r\n                        throw new Error('Can not overwrite member \"' +\r\n                            name + '\" which has previously been defined');\r\n                    }\r\n\r\n                    const member = publicMembers[name];\r\n                    const memberIsRequired = isRequired(member);\r\n                    const fn = function () {\r\n                        return member.apply(privateContext, arguments);\r\n                    };\r\n\r\n                    const instanceHasMemberWithSameName = \r\n                        hasOwnProperty.call(instance, name);\r\n\r\n                    const instanceMemberWithSameNameIsRequired =\r\n                        instanceHasMemberWithSameName &&\r\n                            isRequired(instance[name]);\r\n\r\n                    const instanceMemberWithSameNameIsImplementation =\r\n                        instanceHasMemberWithSameName &&\r\n                            !isRequired(instance[name]);\r\n\r\n                    if (memberIsRequired && \r\n                        instanceMemberWithSameNameIsRequired) {\r\n                        // Do nothing, both are required so we\r\n                        // wait for an actual implementation\r\n                    }\r\n                    else if (memberIsRequired &&\r\n                            instanceMemberWithSameNameIsImplementation) {\r\n                        // Do nothing, the implementation is already\r\n                        // attached to the instance\r\n                    }\r\n                    else if (memberIsRequired && \r\n                            !instanceHasMemberWithSameName) {\r\n                        // This declares a new required member and\r\n                        // we still wait for the implementation\r\n                        instance[name] = member;\r\n                    }\r\n                    else if (!memberIsRequired &&\r\n                            (instanceMemberWithSameNameIsRequired ||\r\n                             !instanceHasMemberWithSameName)) {\r\n                        // Overwrite the required statement with the\r\n                        // specified implementation\r\n                        privateContext[name] = fn;\r\n                        instance[name] = fn;\r\n                    }\r\n                    else {\r\n                        throw new Error('Unknown composition pattern');\r\n                    }\r\n                });\r\n        };\r\n    }\r\n\r\n    function createInstance(t, config = {}) {\r\n        if (!isTrait(t)) {\r\n            throw new Error('The argument \"' + JSON.stringify(t) + '\" is ' +\r\n                'not a trait and therefore can not be instantiated.');\r\n        }\r\n\r\n        const descriptor = retrieveMetaData(t);\r\n        let instance = {};\r\n        let traits = [t].concat(descriptor.traits);\r\n\r\n        const applyStatefulTrait = closeOverInstance(instance, config);\r\n        traits.forEach(applyStatefulTrait);\r\n\r\n        Object_keys(instance).forEach(name => {\r\n            const member = instance[name];\r\n\r\n            if (isRequired(member)) {\r\n                throw new Error('Can not instantiate incomplete ' +\r\n                    'trait. The member \"' + name + \r\n                    '\" is still required.');\r\n            }\r\n        });\r\n\r\n        return instance;\r\n    }\r\n\r\n    // The main entry point for our library\r\n    function trait(descriptor) {\r\n        if (typeof descriptor === 'function') {\r\n            descriptor = descriptor(createInstance(trait.Util, trait.config));\r\n        }\r\n\r\n        let { constructor, requires } = extractDependencies(descriptor);\r\n        let { traits } = extractTraits(descriptor);\r\n        let { main } = extractMain(descriptor);\r\n        let { publicMethods } = extractPublicMethods(descriptor);\r\n        let { privateMethods } = extractPrivateMethods(descriptor);\r\n\r\n        return makeTrait({\r\n            traits: traits,\r\n            requires: requires,\r\n            constructor: constructor,\r\n            main: main,\r\n            public: publicMethods,\r\n            private: privateMethods\r\n        });\r\n    }\r\n\r\n    return Object_freeze(mix(trait, {\r\n        Util: trait({\r\n            public: {\r\n                requires: requires,\r\n                log() { console.log(...arguments); }\r\n            }\r\n        }),\r\n        config: {},\r\n        create: createInstance,\r\n        isTrait: isTrait,\r\n        required: Object_freeze(new Required())\r\n    }));\r\n}));\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"sourceRoot":"/source/"}