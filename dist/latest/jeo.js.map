{"version":3,"sources":["jeo.js"],"names":["_slicedToArray","arr","i","Array","isArray","Symbol","iterator","Object","_step","_arr","_iterator","next","done","push","value","length","TypeError","global","name","factory","define","amd","module","exports","eval","mix","to","from","undefined","arguments","Object_keys","forEach","key","assert","condition","message","Error","requires","extractDependencies","descriptor","toBeDefined","not","toBeNull","constructor","hasOwnProperty","call","constructorArgumentCount","hasRequires","requiresSetting","dependencyCount","JSON","stringify","dependency","isTrait","extractTraits","hasTraits","traits","is","t","extractMain","hasMain","main","Required","isRequired","object","extractPublicMembers","hasPublicMembers","publicMembers","item","member","publicName","privateName","extractPrivateMembers","hasPrivateMembers","privateMembers","storeMetaData","metaData","givenEvidence","secretEvidence","retrieveMetaData","expando","resolveDescriptor","resolver","projection","Object_create","result","publicKeyMap","_descriptor$public$name","hasRule","rule","makeTrait","resolve","create","createToplevelInstanceFactory","Object_freeze","makeHash","hash","map","filter","m","sort","join","closeOverInstance","instance","config","contexts","_config$for$filter","tt","trait","_config$for$filter2","substitute","substituteHash","use","hashOfT","dependencies","dep","createInstance","privateContext","apply","_publicMembers$name","memberIsRequired","fn","instanceHasMemberWithSameName","instanceMemberWithSameNameIsRequired","instanceMemberWithSameNameIsImplementation","concat","applyStatefulTrait","_x","_arguments","_again","args","_extractDependencies","_extractTraits","_extractMain","_extractPublicMembers","_extractPrivateMembers","Util","public","private","slice","arg","currentConfig","freeze","keys","requiresExtensions","extension","thingy","ok","Math","round","random","log","console","for","required"],"mappings":"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","file":"jeo.js","sourcesContent":["/*! jeo v0.2.1 (c) 2015 Martin Feineis, MIT license (https://www.github.com/mfeineis/jeo) */\r\n/*jshint esnext:true, maxlen:80 */\r\n/*global define,module */\r\n(function (global, name, factory) {\r\n    'use strict';\r\n\r\n    if (typeof define !== 'undefined' && define.amd) {\r\n        // AMD\r\n        define([], factory);\r\n    }\r\n    else if (typeof module !== 'undefined') {\r\n        // CommonJS\r\n        module.exports = factory();\r\n    }\r\n    else {\r\n        // No modules\r\n        global[name] = factory();\r\n    }\r\n\r\n}((0, eval)('this'), 'jeo', () => {\r\n    'use strict';\r\n\r\n    const Object_create = Object.create;\r\n    const Object_freeze = Object.freeze;\r\n    const Object_keys = Object.keys;\r\n    const hasOwnProperty = {}.hasOwnProperty;\r\n\r\n    function mix(to, from = {}) {\r\n        \r\n        Object_keys(from).forEach(key => {\r\n            to[key] = from[key];\r\n        });\r\n\r\n        return to;\r\n    }\r\n\r\n    function assert(condition, message = 'An assertion failed.') {\r\n        if (!condition) {\r\n            throw new Error(message);\r\n        }\r\n    }\r\n\r\n    // Used to check preconditions\r\n    function requires(\r\n        condition, \r\n        message = 'A precondition has been violated.') {\r\n        if (!condition) {\r\n            throw new Error(message);\r\n        }\r\n    }\r\n    requires.not = {};\r\n\r\n    var requiresExtensions = {\r\n        toBeDefined(object) {\r\n            return typeof object !== 'undefined';\r\n        },\r\n        toBeNull(object) {\r\n            return object === null;\r\n        }\r\n    };\r\n\r\n    // Putting the extensions and their inverses onto the\r\n    // requires function\r\n    Object_keys(requiresExtensions).forEach(key => {\r\n\r\n        requires[key] = (function (extension) {\r\n            return function (thingy, message) {\r\n                const ok = extension(...arguments);\r\n                requires(ok, message);\r\n            };\r\n        }(requiresExtensions[key]));\r\n\r\n        requires.not[key] = (function (extension) {\r\n            return function (thingy, message) {\r\n                const ok = !extension(...arguments);\r\n                requires(ok, message);\r\n            };\r\n        }(requiresExtensions[key]));\r\n\r\n    });\r\n\r\n    function extractDependencies(descriptor) {\r\n        requires.toBeDefined(descriptor, 'No descriptor specified.');\r\n        requires.not.toBeNull(descriptor, 'A descriptor can not be null.');\r\n\r\n        const constructor = hasOwnProperty.call(descriptor, 'constructor') \r\n            ? descriptor.constructor\r\n            : function () {};\r\n        const constructorArgumentCount = constructor.length;\r\n\r\n        if (typeof constructor !== 'function') {\r\n            throw new Error('\"constructor\" must be a function.');\r\n        }\r\n\r\n        const hasRequires = hasOwnProperty.call(descriptor, 'requires');\r\n        const requiresSetting = hasRequires\r\n            ? (Array.isArray(descriptor.requires) \r\n                ? descriptor.requires\r\n                : [descriptor.requires])\r\n            : [];\r\n        const dependencyCount = requiresSetting.length;\r\n\r\n        if (constructorArgumentCount === 0 && dependencyCount > 0) {\r\n            throw new Error('\"requires\" is not allowed to provide ' +\r\n                    'dependencies when the constructor doesn\\'t require any');\r\n        }\r\n\r\n        if (constructorArgumentCount !== dependencyCount) {\r\n            throw new Error('\"requires\" has to provide the same amount of ' +\r\n                    'dependencies that the constructor declares (' + \r\n                        JSON.stringify(descriptor) + ')');\r\n        }\r\n\r\n        requiresSetting.forEach(dependency => {\r\n           if (!isTrait(dependency)) {\r\n               throw new Error('\"' + JSON.stringify(dependency) +'\" is not ' +\r\n                   'a valid trait');\r\n           } \r\n        });\r\n\r\n        return {\r\n            constructor: constructor,\r\n            requires: requiresSetting\r\n        };\r\n    }\r\n\r\n    function extractTraits(descriptor) {\r\n        const hasTraits = hasOwnProperty.call(descriptor, 'is');\r\n        const traits = hasTraits\r\n            ? (Array.isArray(descriptor.is)\r\n                ? descriptor.is\r\n                : [descriptor.is])\r\n            : [];\r\n\r\n        traits.forEach(t => {\r\n            if (!isTrait(t)) {\r\n                throw new Error('\"' + JSON.stringify(t) + '\" is not ' +\r\n                    'a valid trait');\r\n            }\r\n        });\r\n\r\n        return {\r\n            traits: traits\r\n        };\r\n    }\r\n\r\n    function extractMain(descriptor) {\r\n        const hasMain = hasOwnProperty.call(descriptor, 'main');\r\n        const main = hasMain\r\n            ? descriptor.main\r\n            : function () {};\r\n\r\n        if (typeof main !== 'function') {\r\n            throw new Error('\"main\", if provided has to be a function.');\r\n        }\r\n\r\n        return {\r\n            main: main\r\n        };\r\n    }\r\n\r\n    function Required() {}\r\n\r\n    function isRequired(object) {\r\n        return object instanceof Required;\r\n    }\r\n\r\n    function extractPublicMembers(descriptor) {\r\n        const hasPublicMembers = hasOwnProperty.call(descriptor, 'public');\r\n        const publicMembers = hasPublicMembers\r\n            ? descriptor.public\r\n            : {};\r\n\r\n        if (typeof publicMembers !== 'object') {\r\n            throw new Error('\"public\" has to be an object.');\r\n        }\r\n\r\n        Object_keys(publicMembers).forEach(name => {\r\n            const item = publicMembers[name];\r\n\r\n            if (!isRequired(item) && typeof item !== 'function') {\r\n                throw new Error('\"public\" can only contain functions or ' +\r\n                    ' \"required\" declarations (' +\r\n                    JSON.stringify(publicMembers) + ')');\r\n            }\r\n\r\n            publicMembers[name] = {\r\n                member: item,\r\n                publicName: name,\r\n                privateName: name\r\n            };\r\n        });\r\n\r\n        return {\r\n            publicMembers: publicMembers \r\n        };\r\n    }\r\n\r\n    function extractPrivateMembers(descriptor) {\r\n        const hasPrivateMembers = hasOwnProperty.call(descriptor, 'private');\r\n\r\n        const privateMembers = hasPrivateMembers\r\n            ? descriptor.private\r\n            : {};\r\n\r\n        if (typeof privateMembers !== 'object') {\r\n            throw new Error('\"private\" has to be an object.');\r\n        }\r\n\r\n        Object_keys(privateMembers).forEach(name => {\r\n            if (typeof privateMembers[name] !== 'function') {\r\n                throw new Error('\"private\" can only contain functions (' +\r\n                    JSON.stringify(privateMembers) + ')');\r\n            }\r\n        });\r\n\r\n        return {\r\n            privateMembers: privateMembers\r\n        };\r\n    }\r\n\r\n    // Our expando property being used to store trait meta data\r\n    const expando = '__jeo_trait' + Math.round(Math.random() * 1000000000);\r\n\r\n    // This is a private key for securing our meta data against manipulation\r\n    const secretEvidence = { isTrait: true };\r\n\r\n    function storeMetaData(metaData) {\r\n        return function checkEvidenceValid(givenEvidence) {\r\n            if (givenEvidence === secretEvidence) {\r\n                return metaData;\r\n            }\r\n            else {\r\n                return undefined;\r\n            }\r\n        };\r\n    }\r\n\r\n    function retrieveMetaData(t) {\r\n        if (typeof t[expando] === 'function') {\r\n            return t[expando](secretEvidence);\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    function isTrait(object) {\r\n        if (!object) {\r\n            throw new Error('Argument to \"isTrait\" can not be null ' +\r\n                'or undefined.');\r\n        }\r\n        if (typeof object[expando] === 'function') {\r\n            return !!retrieveMetaData(object);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function resolveDescriptor(descriptor, resolver) {\r\n        const projection = Object_create(descriptor);\r\n        const result = projection.public = {};\r\n        const publicKeyMap = {};\r\n\r\n        Object_keys(descriptor.public)\r\n            .forEach(name => {\r\n                publicKeyMap[name] = true;\r\n\r\n                const { \r\n                    member, \r\n                    publicName, \r\n                    privateName \r\n                } = descriptor.public[name];\r\n\r\n                const hasRule = hasOwnProperty.call(resolver, name);\r\n                const rule = resolver[name];\r\n                \r\n                if (hasRule) {\r\n                    if (isRequired(member)) {\r\n                        throw new Error('Can not resolve required ' +\r\n                            'member \"' + name + '\".');\r\n                    }\r\n\r\n                    if (rule === null) {\r\n                        if (publicName === null) {\r\n                            // The member is already hidden from the\r\n                            // public api\r\n                            throw new Error('No public member \"' +\r\n                                name + '\" found');\r\n                        }\r\n\r\n                        // Hide\r\n                        result[name] = {\r\n                            member: member,\r\n                            publicName: null,\r\n                            privateName: privateName\r\n                        };\r\n                        return;\r\n                    }\r\n\r\n                    if (typeof rule === 'string') {\r\n                        // Rename\r\n                        result[rule] = {\r\n                            member: member,\r\n                            publicName: rule,\r\n                            privateName: privateName\r\n                        };\r\n                        return;\r\n                    }\r\n                }\r\n                else {\r\n                    // Copy\r\n                    result[name] = {\r\n                        member: member,\r\n                        publicName: publicName,\r\n                        privateName: privateName\r\n                    };\r\n                }\r\n            });\r\n\r\n        Object_keys(resolver).forEach(name => {\r\n            if (!hasOwnProperty.call(publicKeyMap, name)) {\r\n                throw new Error('\"' + name + '\" can not be resolved ' +\r\n                    'because it is not a public method on ' + \r\n                    JSON.stringify(descriptor));\r\n            }\r\n        });\r\n\r\n        return projection;\r\n    }\r\n\r\n    function makeTrait(descriptor) {\r\n\r\n        const t = {\r\n            resolve(resolver) {\r\n                return makeTrait(resolveDescriptor(descriptor, resolver));\r\n            }\r\n        };\r\n        t.create = createToplevelInstanceFactory(t);\r\n        t[expando] = storeMetaData(descriptor);\r\n\r\n        return Object_freeze(t);\r\n    }\r\n\r\n    function makeHash(t) {\r\n        const publicMembers = retrieveMetaData(t).public;\r\n        let hash = Object_keys(publicMembers)\r\n            .map(name => publicMembers[name].publicName)\r\n            .filter(m => m !== null);\r\n        hash.sort();\r\n        return hash.join('#');\r\n    }\r\n\r\n    function closeOverInstance(instance, config) {\r\n        // DEBUG\r\n        instance.contexts = [];\r\n        // DEBUG-END\r\n        \r\n        return function applyStatefulTrait(t) {\r\n            let [substitute] = config.for.filter(tt => tt.trait === t);\r\n            if (substitute) {\r\n                let substituteHash = makeHash(substitute.use);\r\n                let hashOfT = makeHash(t);\r\n\r\n                if (hashOfT !== substituteHash) {\r\n                    throw new Error('Substitute hash \"' + substituteHash + \r\n                        '\" does not match the hash \"' + hashOfT + '\" of ' +\r\n                        'the trait to be substituted');\r\n                }\r\n                t = substitute.use;\r\n            }\r\n\r\n            const descriptor = retrieveMetaData(t);\r\n            const publicMembers = descriptor.public;\r\n            const privateMembers = descriptor.private;\r\n            const dependencies = descriptor.requires\r\n                .map(dep => createInstance(dep, config));\r\n\r\n            const privateContext = {};\r\n\r\n            // DEBUG\r\n            instance.contexts.push(privateContext);\r\n            // DEBUG-END\r\n            \r\n            descriptor.constructor.apply(privateContext, dependencies);\r\n\r\n            Object_keys(privateMembers)\r\n                .forEach(name => {\r\n                    const member = privateMembers[name];\r\n\r\n                    if (isRequired(member)) {\r\n                        throw new Error('Private members can not be ' +\r\n                            'required');\r\n                    }\r\n\r\n                    if (hasOwnProperty.call(privateContext, name)) {\r\n                        throw new Error('Can not overwrite member \"' +\r\n                            name + '\" which has previously been defined');\r\n                    }\r\n\r\n                    privateContext[name] = function () {\r\n                        return member.apply(privateContext, arguments);\r\n                    };\r\n                });\r\n\r\n            Object_keys(publicMembers)\r\n                .forEach(name => {\r\n                    const { \r\n                        member, \r\n                        publicName,\r\n                        privateName\r\n                    } = publicMembers[name];\r\n\r\n                    if (hasOwnProperty.call(privateContext, privateName)) {\r\n                        throw new Error('Can not overwrite member \"' +\r\n                            name + '\" which has previously been defined');\r\n                    }\r\n\r\n                    const memberIsRequired = isRequired(member);\r\n                    const fn = function () {\r\n                        return member.apply(privateContext, arguments);\r\n                    };\r\n\r\n                    const instanceHasMemberWithSameName = \r\n                        hasOwnProperty.call(instance, publicName);\r\n\r\n                    const instanceMemberWithSameNameIsRequired =\r\n                        instanceHasMemberWithSameName &&\r\n                            isRequired(instance[publicName]);\r\n\r\n                    const instanceMemberWithSameNameIsImplementation =\r\n                        instanceHasMemberWithSameName &&\r\n                            !isRequired(instance[publicName]);\r\n\r\n                    if (memberIsRequired && \r\n                        instanceMemberWithSameNameIsRequired) {\r\n                        // Do nothing, both are required so we\r\n                        // wait for an actual implementation\r\n                    }\r\n                    else if (memberIsRequired &&\r\n                            instanceMemberWithSameNameIsImplementation) {\r\n                        // Do nothing, the implementation is already\r\n                        // attached to the instance\r\n                    }\r\n                    else if (memberIsRequired && \r\n                            !instanceHasMemberWithSameName) {\r\n                        // This declares a new required member and\r\n                        // we still wait for the implementation\r\n                        instance[publicName] = member;\r\n                    }\r\n                    else if (!memberIsRequired &&\r\n                            (instanceMemberWithSameNameIsRequired ||\r\n                             !instanceHasMemberWithSameName)) {\r\n                        // Overwrite the required statement with the\r\n                        // specified implementation\r\n                        privateContext[privateName] = fn;\r\n\r\n                        if (publicName !== null) {\r\n                            instance[publicName] = fn;\r\n                        }\r\n                    }\r\n                    else {\r\n                        throw new Error('Unknown composition pattern');\r\n                    }\r\n                });\r\n        };\r\n    }\r\n\r\n    function createInstance(t, config) {\r\n        if (!isTrait(t)) {\r\n            throw new Error('The argument \"' + JSON.stringify(t) + '\" is ' +\r\n                'not a trait and therefore can not be instantiated.');\r\n        }\r\n\r\n        const descriptor = retrieveMetaData(t);\r\n        let instance = {};\r\n        let traits = [t].concat(descriptor.is);\r\n\r\n        const applyStatefulTrait = closeOverInstance(instance, config);\r\n        traits.forEach(applyStatefulTrait);\r\n\r\n        Object_keys(instance).forEach(name => {\r\n            const member = instance[name];\r\n\r\n            if (isRequired(member)) {\r\n                throw new Error('Can not instantiate incomplete ' +\r\n                    'trait. The member \"' + name + \r\n                    '\" is still required.');\r\n            }\r\n        });\r\n\r\n        return instance;\r\n    }\r\n\r\n    // The main entry point for our library\r\n    function trait(descriptor) {\r\n        if (arguments.length > 1) {\r\n            const args = [].slice.call(arguments).map(arg => {\r\n                if (!arg) {\r\n                    throw new Error('A top level argument can not be falsy');\r\n                }\r\n\r\n                if (!isTrait(arg)) {\r\n                    return trait({ public: arg });\r\n                }\r\n                else {\r\n                    return arg;\r\n                }\r\n            });\r\n            return trait({ is: args });\r\n        }\r\n\r\n        if (typeof descriptor === 'function') {\r\n            descriptor = descriptor(createInstance(trait.Util, trait.config));\r\n        }\r\n\r\n        let { constructor, requires } = extractDependencies(descriptor);\r\n        let { traits } = extractTraits(descriptor);\r\n        let { main } = extractMain(descriptor);\r\n        let { publicMembers } = extractPublicMembers(descriptor);\r\n        let { privateMembers } = extractPrivateMembers(descriptor);\r\n\r\n        return makeTrait({\r\n            is: traits,\r\n            requires: requires,\r\n            constructor: constructor,\r\n            main: main,\r\n            public: publicMembers,\r\n            private: privateMembers\r\n        });\r\n    }\r\n\r\n    function createToplevelInstanceFactory(t) {\r\n        return function createToplevelInstance(config = {}) {\r\n            const currentConfig = mix(trait.config, config);\r\n\r\n            currentConfig.for.forEach(item => {\r\n                if (!isTrait(item.trait)) {\r\n                    throw new Error('Invalid configured dependency');\r\n                }\r\n                if (!isTrait(item.use)) {\r\n                    throw new Error('Invalid substituted dependency ' +\r\n                        'configured');\r\n                }\r\n            });\r\n\r\n            return createInstance(t, currentConfig);\r\n        };\r\n    }\r\n\r\n    return {\r\n        trait: Object_freeze(mix(trait, {\r\n            Util: trait({\r\n                public: {\r\n                    assert: assert,\r\n                    log() { console.log(...arguments); },\r\n                    mix: mix,\r\n                    requires: requires\r\n                }\r\n            }),\r\n            config: { for: [] },\r\n            isTrait: isTrait,\r\n            required: Object_freeze(new Required())\r\n        }))\r\n    };\r\n}));\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* -===========================- 80 chars width -=========================- */\r\n"],"sourceRoot":"/source/"}