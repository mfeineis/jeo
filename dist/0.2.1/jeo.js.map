{"version":3,"sources":["jeo.js"],"names":["e","t","n","r","s","o","u","a","require","i","Error","f","exports","call","length",1,"module","_slicedToArray","arr","Array","isArray","Symbol","iterator","Object","_step","_arr","_iterator","next","done","push","value","TypeError","global","name","factory","define","amd","eval","mix","to","from","undefined","arguments","Object_keys","forEach","key","assert","condition","message","requires","extractDependencies","descriptor","toBeDefined","not","toBeNull","constructor","hasOwnProperty","constructorArgumentCount","hasRequires","requiresSetting","dependencyCount","JSON","stringify","dependency","isTrait","extractTraits","hasTraits","traits","is","extractMain","hasMain","main","Required","isRequired","object","extractPublicMembers","hasPublicMembers","publicMembers","item","member","publicName","privateName","extractPrivateMembers","hasPrivateMembers","privateMembers","storeMetaData","metaData","givenEvidence","secretEvidence","retrieveMetaData","expando","resolveDescriptor","resolver","projection","Object_create","result","publicKeyMap","_descriptor$public$name","hasRule","rule","makeTrait","resolve","create","createToplevelInstanceFactory","Object_freeze","makeHash","hash","map","filter","m","sort","join","closeOverInstance","instance","config","_config$for$filter","tt","trait","_config$for$filter2","substitute","substituteHash","use","hashOfT","dependencies","dep","createInstance","privateContext","apply","_publicMembers$name","memberIsRequired","fn","instanceHasMemberWithSameName","instanceMemberWithSameNameIsRequired","instanceMemberWithSameNameIsImplementation","concat","applyStatefulTrait","_x","_arguments","_again","args","_extractDependencies","_extractTraits","_extractMain","_extractPublicMembers","_extractPrivateMembers","Util","public","private","slice","arg","currentConfig","freeze","keys","requiresExtensions","extension","thingy","ok","Math","round","random","log","console","for","required"],"mappings":"CAAA,QAAUA,GAAEC,EAAEC,EAAEC,GAAG,QAASC,GAAEC,EAAEC,GAAG,IAAIJ,EAAEG,GAAG,CAAC,IAAIJ,EAAEI,GAAG,CAAC,GAAIE,GAAkB,kBAATC,UAAqBA,OAAQ,KAAIF,GAAGC,EAAE,MAAOA,GAAEF,GAAE,EAAI,IAAGI,EAAE,MAAOA,GAAEJ,GAAE,EAAI,MAAM,IAAIK,OAAM,uBAAuBL,EAAE,KAAK,GAAIM,GAAET,EAAEG,IAAIO,WAAYX,GAAEI,GAAG,GAAGQ,KAAKF,EAAEC,QAAQ,SAASZ,GAAG,GAAIE,GAAED,EAAEI,GAAG,GAAGL,EAAG,OAAOI,GAAEF,EAAEA,EAAEF,IAAIW,EAAEA,EAAEC,QAAQZ,EAAEC,EAAEC,EAAEC,GAAG,MAAOD,GAAEG,GAAGO,QAAkD,IAAI,GAA1CH,GAAkB,kBAATD,UAAqBA,QAAgBH,EAAE,EAAEA,EAAEF,EAAEW,OAAOT,IAAID,EAAED,EAAEE,GAAI,OAAOD,KAAKW,GAAG,SAASP,EAAQQ,GAC9a,YAEA,IAAIC,GAAiB,SAAUC,EAAKT,GAAK,GAAIU,MAAMC,QAAQF,GAAQ,MAAOA,EAAY,IAAIG,OAAOC,WAAYC,QAAOL,GAAM,CAAiB,IAAK,GAAwCM,GAAxDC,KAAoBC,EAAYR,EAAIG,OAAOC,cAAsBE,EAAQE,EAAUC,QAAQC,OAASH,EAAKI,KAAKL,EAAMM,QAAYrB,GAAKgB,EAAKX,SAAWL,KAAY,MAAOgB,GAAe,KAAM,IAAIM,WAAU;CACvU,SAAAC,EAAaC,EAAAC,GAOS,mBAAXC,SAA0BA,OAAOC,IAF3CD,UACQD,GAIoB,mBAAXlB,GADjBA,EACIJ,QAAAsB,IAGJF,EAAAC,GAAAC,MAGD,EAAAG,MAAA,QAAa,MAAA,WASb,QAFiBC,GAAIC,GAGjB,GAAIC,GAAwBC,SAAjBC,UAAU,MAAwBA,UAAU,EAI1D,OAJOC,GAAOH,GAAOI,QAAM,SAAAC,GACrBN,EAAAM,GAAAL,EAAAK,KAGNN,EAKD,QAH2BO,GAAOC,GAI9B,GAAIC,GAA2BP,SAAjBC,UAAU,GAAmB,uBAAyBA,UAAU,EAF1E,KAAAK,EACH,KAAA,IAAArC,OAAAsC,GASL,QAHIC,GAAOF,GAIP,GAAIC,GAA2BP,SAAjBC,UAAU,GAAmB,oCAAsCA,UAAU,EAFvF,KAAAK,EACH,KAAA,IAAArC,OAAAsC,GAkCD,QAAAE,GAAqBC,GACrBF,EAASG,YAAYD,EAAW,4BAIhCF,EAASI,IAAIC,SAASH,EAAY,gCAClC,IAAMI,GAAAC,EAA2B3C,KAAAsC,EAAmB,eAAAA,EAAAI,YAAA,aAEhDE,EAA2BF,EAAYzC,MACvC,IAAgB,kBAAVyC,GACT,KAAA,IAAA7C,OAAA,oCAGD,IAAMgD,GAAAF,EAA6B3C,KAC5BsC,EAAc,YAIfQ,EAAkBD,EAAAvC,MAAgBC,QAAO+B,EAAAF,UAAAE,EAAAF,UAAAE,EAAAF,aAF3CW,EAAkBD,EAAgB7C,MAKlC,IAAgB,IAAhB2C,GAAgBG,EAAA,EAEnB,KAAA,IAAAlD,OAAA,8FAGG,IAAA+C,IAAgBG,EAGnB,KAAA,IAAAlD,OAAA,4FAAAmD,KAAAC,UAAAX,GAAA,IAUG,OAPDQ,GAAYf,QAAC,SAAamB,GACtB,IAAAC,EAAMD,GAET,KAAA,IAAArD,OAAA,IAAAmD,KAAAC,UAAAC,GAAA,6BAKAR,YAAUA,EACZN,SAAAU,GAIF,QAAMM,GAAYd,GAClB,GAAMe,GAASV,EACF3C,KAAAsC,EAAQ,MAPjBgB,EAASD,EAAY/C,MAAMC,QAAQ+B,EAAWiB,IAAMjB,EAAWiB,IAAMjB,EAAWiB,MAoBhF,OAPAD,GAAAvB,QAAK,SAAY3C,GACb,IAAA+D,EAAM/D,GAET,KAAA,IAAAS,OAAA,IAAAmD,KAAAC,UAAA7D,GAAA,6BAKHkE,OAAAA,GAIF,QAAME,GAAUlB,GAChB,GAAMmB,GAAOd,EACP3C,KAAWsC,EACX,QAbFoB,EAAOD,EAAUnB,EAAWoB,KAAO,YAgBnC,IAAgB,kBAAVA,GACT,KAAA,IAAA7D,OAAA,4CAGG,QACF6D,KAAAA,GAVN,QAASC,MAgBL,QAAAC,GAAaC,GAChB,MAAAA,aAAAF,GAGG,QAAMG,GAAmBxB,GACzB,GAAMyB,GAAgBpB,EAAgB3C,KAChCsC,EAAU,UAdZ0B,EAAgBD,EAAmBzB,EAAW,YAkB9C,IAAgB,gBAAV0B,GACT,KAAA,IAAAnE,OAAA,gCAmBG,OAhBAiC,GAAUkC,GAAGjC,QAAoB,SAAAX,GAfjC,GAAI6C,GAAOD,EAAc5C,EAkBrB,KAAAwC,EAAUK,IAAM,kBAAAA,GAGnB,KAAA,IAAApE,OAAA,oEAAAmD,KAAAC,UAAAe,GAAA,IAGGA,GAAQ5C,IACR8C,OAAAD,EACAE,WAAW/C,EACbgD,YAAAhD,MAKJ4C,cAAAA,GAIF,QAAMK,GAAoB/B,GAjB1B,GAAIgC,GAAoB3B,EAAe3C,KAAKsC,EAAY,WAEpDiC,EAAiBD,EAAoBhC,EAAW,aAsBhD,IAAgB,gBAAViC,GACT,KAAA,IAAA1E,OAAA,iCAUG,OAPAiC,GAAIyC,GAAOxC,QAAoB,SAAKX,GAChC,GAAgB,kBAAVmD,GAAUnD,GAEnB,KAAA,IAAAvB,OAAA,yCAAAmD,KAAAC,UAAAsB,GAAA,QAKHA,eAAAA,GAUF,QAAAC,GAAgBC,GACZ,MAAA,UAAsBC,GAClB,MAAAA,KAAgBC,EAEfF,EAEJ7C,QAKL,QAAIgD,GAAiBxF,GACjB,MAAkB,kBAAXA,GAAEyF,GAERzF,EAAAyF,GAAAF,GAEJ/C,OAID,QAAIuB,GAAOU,GACP,MAA0B,kBAAnBA,GAAEgB,KAERD,EAAAf,IAEJ,EAID,QAAMiB,GAAaxC,EAAcyC,GACjC,GAAMC,GAASC,EAAU3C,GACnB4C,EAAAF,EAAkB,aAvBpBG,IA0FP,OA/DWrD,GAAAQ,EAAkB,WAAQP,QAAA,SAAAX,GAxB9B+D,EAAa/D,IAAQ,CAErB,IAyBQgE,GAAM9C,EAAN,UAAMlB,GACN8C,EAAAkB,EAAUlB,OACVC,EAAWiB,EAAAjB,WAxBfC,EAAcgB,EAAwBhB,YA4BhCiB,EAAO1C,EAAe3C,KAAA+E,EAAA3D,GAzB5BkE,EAAOP,EAAS3D,EA4BZ,IAAAiE,EAAI,CACA,GAAAzB,EAAUM,GAEb,KAAA,IAAArE,OAAA,oCAAAuB,EAAA,KAGG,IAAI,OAAJkE,EAAc,CA1BlB,GAAmB,OAAfnB,EA+BC,KAAA,IAAAtE,OAAA,qBAAAuB,EAAA,UASJ,aALO8D,EAAA9D,IACA8C,OAAAA,EACAC,WAAW,KACbC,YAAAA,IAvBV,GAAoB,gBAATkB,GAmCN,YALOJ,EAAAI,IACApB,OAAAA,EACAC,WAAWmB,EACblB,YAAAA,QAOFc,GAAA9D,IACA8C,OAAAA,EACAC,WAAWA,EACbC,YAAAA,KAKVtC,EAAKiD,GAAAhD,QAAoB,SAAAX,GACrB,IAAAuB,EAAgB3C,KAAGmF,EAAU/D,GAGhC,KAAA,IAAAvB,OAAA,IAAAuB,EAAA,8DAAA4B,KAAAC,UAAAX,MAIR0C,EA5BD,QAASO,GAAUjD,GAiCX,GAAAlD,IACIoG,QAAA,SAAiBT,GACpB,MAAAQ,GAAAT,EAAAxC,EAAAyC,KAMR,OAHG3F,GAAEqG,OAAQC,EAA6BtG,GA9BvCA,EAAEyF,GAAWL,EAAclC,GAiC9BqD,EAAAvG,GAGG,QAAMwG,GAAAxG,GACN,GAAI4E,GAAOY,EAA0BxF,GAChC,UA/BDyG,EA+Ba/D,EAAAkC,GAAoB8B,IAAU,SAAA1E,GAC1C,MAAO4C,GAAC5C,GAAA+C,aA9BV4B,OAAO,SA8BaC,GAAM,MAAA,QAAAA,GAGhC,OADGH,GAAAI,OACHJ,EAAAK,KAAA,KAGG,QAAAC,GAAgBC,EAAAC,GA5BhB,MAAO,UA6BsBjH,GA5BzB,GAAIkH,GA4BqDD,EAAA,OAAAN,OAAA,SAAAQ,GAAC,MAAAA,GAAAC,QAAApH,IAxBtDqH,EAAsBrG,EAAekG,EAAoB,GAEzDI,EAAaD,EAAoB,EAwBjC,IAAAC,EAAI,CACJ,GAAIC,GAAUf,EAAYc,EAAAE,KArBtBC,EAAUjB,EAASxG,EAwBnB,IAAAyH,IAAUF,EAGb,KAAA,IAAA9G,OAAA,mBAAA8G,EAAA,8BAAAE,EAAA,mCAEJzH,GAAAsH,EAAAE,IAGD,GAAMtE,GAAasC,EAAaxF,GAC1B4E,EAAc1B,EAAa,UAC3BiC,EAAejC,EAAW,WAvB5BwE,EAwBYxE,EAAkBF,SAAS0D,IAAA,SAAAiB,GAAE,MAAAC,GAAAD,EAAAV,KApBzCY,IAEJ3E,GAAWI,YAAYwE,MAAMD,EAAgBH,GA0BrChF,EAAMyC,GAASxC,QAAmB,SAAEX,GAvBxC,GAAI8C,GAASK,EAAenD,EA0BpB,IAAAwC,EAAUM,GAEb,KAAA,IAAArE,OAAA,sCAGG,IAAA8C,EAAe3C,KAACiH,EAAA7F,GAEnB,KAAA,IAAAvB,OAAA,6BAAAuB,EAAA,sCAGG6F,GAAO7F,GAAY,WACrB,MAAA8C,GAAAgD,MAAAD,EAAApF,cAtBVC,EAAYkC,GAAejC,QA+Bf,SAAcX,GA9BtB,GA2BQ+F,GAAMnD,EAAA5C,GACN8C,EAAAiD,EAAUjD,OACVC,EAAWgD,EAAAhD,WA1BfC,EAAc+C,EAAoB/C,WA8B9B,IAAAzB,EAAe3C,KAACiH,EAAA7C,GAEnB,KAAA,IAAAvE,OAAA,6BAAAuB,EAAA,sCAGD,IAAMgG,GAAiBxD,EAAAM,GACnBmD,EAAA,WACF,MAAAnD,GAAAgD,MAAAD,EAAApF,YA1BFyF,EAAgC3E,EAAe3C,KAAKoG,EAAUjC,GAE9DoD,EAAuCD,GAAiC1D,EAAWwC,EAASjC,IAE5FqD,EAA6CF,IAAkC1D,EAAWwC,EAASjC,GAEvG,IAAIiD,GAAoBG,OAA8C,IAAIH,GAAoBI,OAAoD,IAAIJ,IAAqBE,EAgDtKlB,EACSjC,GAAAD,MA7CP,CAAA,GAAKkD,IAAqBG,GAAyCD,EA0DrE,KAAA,IAAAzH,OAAA,8BAvDDoH,GAAe7C,GAAeiD,EAkDb,OAATlD,IACHiC,EAAAjC,GAAAkD,OAUjB,QAAKL,GAAY5H,EAAAiH,GACb,IAAAlD,EAAM/D,GAET,KAAA,IAAAS,OAAA,iBAAAmD,KAAAC,UAAA7D,GAAA,0DAGD,IAAIkD,GAAasC,EAACxF,GACdgH,KAjDA9C,GAAUlE,GAAGqI,OAAOnF,EAAWiB,IAoDnCmE,EAAevB,EAAoBC,EAAAC,EAatC,OA9DG/C,GAAOvB,QAAQ2F,GAoDX5F,EAAMsE,GAASrE,QAAa,SAAEX,GAjD9B,GAAI8C,GAASkC,EAAShF,EAoDlB,IAAAwC,EAAUM,GAGb,KAAA,IAAArE,OAAA,qDAAAuB,EAAA,0BAIRgF,EAhDD,QAASI,GAAMmB,GAIA,IAHX,GAAIC,GAAa/F,UACbgG,GAAS,EAEKA,GAAQ,CACtBA,GA8CO,CAED,IAAIvF,GAAAqF,CA9CVG,GAAOC,EAAuBrF,EAAcN,EAAW4F,EAAiB1E,EAAS2E,EAAevE,EAAOwE,EAAwBlE,EAAgBmE,EAAyB5D,EAAiB3C,MA8CzL,EAAA,KAAAgG,EAAa3H,OAAS,GAAtB,CAgBa,kBAAbqC,KACHA,EAAAA,EAAA0E,EAAAR,EAAA4B,KAAA5B,EAAAH,SAxCG,IAAI0B,GAAuB1F,EAAoBC,GA0ChCI,EAAQqF,EAARrF,YAvCXN,EAAW2F,EAAqB3F,SAEhC4F,EAAiB5E,EAAcd,GAE/BgB,EAAS0E,EAAe1E,OAExB2E,EAAezE,EAAYlB,GAE3BoB,EAAOuE,EAAavE,KAEpBwE,EAAwBpE,EAAqBxB,GAE7C0B,EAAgBkE,EAAsBlE,cAEtCmE,EAAyB9D,EAAsB/B,GAE/CiC,EAAiB4D,EAAuB5D,cA8B5C,OAAEgB,IACFhC,GAAAD,EACAlB,SAAAA,EACAM,YAAUA,EACVgB,KAAAA,EACA2E,SAAArE,EACDsE,UAAA/D,IA/BK,GAAAuD,MAAUS,MAAAvI,KAAA4H,GAAA9B,IAAA,SAAA0C,GACN,IAAAA,EACH,KAAA,IAAA3I,OAAA,wCAGG,OAAAsD,GAAOqF,GAIVA,EAFIhC,GAAA6B,SAAAG,KAxCLZ,IAAcD,GAAOpE,GAAIuE,IACzBD,GAAS,IAmEjB,QAAAnC,GAAgBtG,GA1BhB,MAAO,YACH,GAAIiH,GAA0BzE,SAAjBC,UAAU,MAAwBA,UAAU,GAErD4G,EAAgBhH,EAAI+E,EAAMH,OAAQA,EAqCxC,OAVMoC,GAAK,OAAY1G,QAAO,SAAEkC,GACtB,IAAAd,EAAMc,EAAIuC,OACb,KAAA,IAAA3G,OAAA,gCAEG,KAAAsD,EAAMc,EAAI2C,KAEb,KAAA,IAAA/G,OAAA,+CAIPmH,EAAA5H,EAAAqJ,IAjgBN,GAAMxD,GAAgBvE,OAAO+E,OACvBE,EAAcjF,OAAOgI,OACrB5G,EAAcpB,OAAKiI,KAErBhG,KAAsBA,cA4B1BP,GAASI,MAFL,IAAAoG,IACIrG,YAAO,SAAkBsB,GAC5B,MAAA,mBAAAA,IAEGpB,SAAA,SAAuBoB,GAC1B,MAAA,QAAAA,GAUL/B,GAAY8G,GAAoB7G,QAAQ,SAAUC,GAF1CI,EAAAJ,GAAO,SAAgB6G,GACnB,MAAA,UAAWC,EAAS3G,GACpB,GAAA4G,GAASF,EAAI3B,MAAStF,OAAAC,UACxBO,GAAA2G,EAAA5G,KAMHyG,EAAmB5G,IAFlBI,EAAAI,IAAOR,GAAA,SAAkB6G,GACrB,MAAA,UAAYC,EAAS3G,GACrB,GAAA4G,IAASF,EAAW3B,MAAEtF,OAAAC,UACxBO,GAAA2G,EAAA5G,KAGPyG,EAAA5G,KA2HH,IAAI6C,GAAU,cAAgBmE,KAAKC,MAAsB,IAAhBD,KAAKE,UAG1CvE,GAAmBxB,SAAS,EA+U5B,QACIqD,MAAAb,EAAYlE,EAAA+E,GACR4B,KAAA5B,GACI6B,UACApG,OAAGA,EAAKkH,IAAA,WAA4BC,QAAAD,IAAAjC,MAAAkC,QAAAvH,YAEpCJ,IAAAA,EACHW,SAAAA,KAGLiE,QAASgD,UACTlG,QAAQA,EACTmG,SAAA3D,EAAA,GAAAhC,oBAdA","file":"jeo.js","sourcesContent":["/*! jeo v0.2.1 (c) 2015 Martin Feineis, MIT license (https://www.github.com/mfeineis/jeo) */\r\n/*jshint esnext:true, maxlen:80 */\r\n/*global define,module */\r\n(function (global, name, factory) {\r\n    'use strict';\r\n\r\n    if (typeof define !== 'undefined' && define.amd) {\r\n        // AMD\r\n        define([], factory);\r\n    }\r\n    else if (typeof module !== 'undefined') {\r\n        // CommonJS\r\n        module.exports = factory();\r\n    }\r\n    else {\r\n        // No modules\r\n        global[name] = factory();\r\n    }\r\n\r\n}((0, eval)('this'), 'jeo', () => {\r\n    'use strict';\r\n\r\n    const Object_create = Object.create;\r\n    const Object_freeze = Object.freeze;\r\n    const Object_keys = Object.keys;\r\n    const hasOwnProperty = {}.hasOwnProperty;\r\n\r\n    function mix(to, from = {}) {\r\n        \r\n        Object_keys(from).forEach(key => {\r\n            to[key] = from[key];\r\n        });\r\n\r\n        return to;\r\n    }\r\n\r\n    function assert(condition, message = 'An assertion failed.') {\r\n        if (!condition) {\r\n            throw new Error(message);\r\n        }\r\n    }\r\n\r\n    // Used to check preconditions\r\n    function requires(\r\n        condition, \r\n        message = 'A precondition has been violated.') {\r\n        if (!condition) {\r\n            throw new Error(message);\r\n        }\r\n    }\r\n    requires.not = {};\r\n\r\n    var requiresExtensions = {\r\n        toBeDefined(object) {\r\n            return typeof object !== 'undefined';\r\n        },\r\n        toBeNull(object) {\r\n            return object === null;\r\n        }\r\n    };\r\n\r\n    // Putting the extensions and their inverses onto the\r\n    // requires function\r\n    Object_keys(requiresExtensions).forEach(key => {\r\n\r\n        requires[key] = (function (extension) {\r\n            return function (thingy, message) {\r\n                const ok = extension(...arguments);\r\n                requires(ok, message);\r\n            };\r\n        }(requiresExtensions[key]));\r\n\r\n        requires.not[key] = (function (extension) {\r\n            return function (thingy, message) {\r\n                const ok = !extension(...arguments);\r\n                requires(ok, message);\r\n            };\r\n        }(requiresExtensions[key]));\r\n\r\n    });\r\n\r\n    function extractDependencies(descriptor) {\r\n        requires.toBeDefined(descriptor, 'No descriptor specified.');\r\n        requires.not.toBeNull(descriptor, 'A descriptor can not be null.');\r\n\r\n        const constructor = hasOwnProperty.call(descriptor, 'constructor') \r\n            ? descriptor.constructor\r\n            : function () {};\r\n        const constructorArgumentCount = constructor.length;\r\n\r\n        if (typeof constructor !== 'function') {\r\n            throw new Error('\"constructor\" must be a function.');\r\n        }\r\n\r\n        const hasRequires = hasOwnProperty.call(descriptor, 'requires');\r\n        const requiresSetting = hasRequires\r\n            ? (Array.isArray(descriptor.requires) \r\n                ? descriptor.requires\r\n                : [descriptor.requires])\r\n            : [];\r\n        const dependencyCount = requiresSetting.length;\r\n\r\n        if (constructorArgumentCount === 0 && dependencyCount > 0) {\r\n            throw new Error('\"requires\" is not allowed to provide ' +\r\n                    'dependencies when the constructor doesn\\'t require any');\r\n        }\r\n\r\n        if (constructorArgumentCount !== dependencyCount) {\r\n            throw new Error('\"requires\" has to provide the same amount of ' +\r\n                    'dependencies that the constructor declares (' + \r\n                        JSON.stringify(descriptor) + ')');\r\n        }\r\n\r\n        requiresSetting.forEach(dependency => {\r\n           if (!isTrait(dependency)) {\r\n               throw new Error('\"' + JSON.stringify(dependency) +'\" is not ' +\r\n                   'a valid trait');\r\n           } \r\n        });\r\n\r\n        return {\r\n            constructor: constructor,\r\n            requires: requiresSetting\r\n        };\r\n    }\r\n\r\n    function extractTraits(descriptor) {\r\n        const hasTraits = hasOwnProperty.call(descriptor, 'is');\r\n        const traits = hasTraits\r\n            ? (Array.isArray(descriptor.is)\r\n                ? descriptor.is\r\n                : [descriptor.is])\r\n            : [];\r\n\r\n        traits.forEach(t => {\r\n            if (!isTrait(t)) {\r\n                throw new Error('\"' + JSON.stringify(t) + '\" is not ' +\r\n                    'a valid trait');\r\n            }\r\n        });\r\n\r\n        return {\r\n            traits: traits\r\n        };\r\n    }\r\n\r\n    function extractMain(descriptor) {\r\n        const hasMain = hasOwnProperty.call(descriptor, 'main');\r\n        const main = hasMain\r\n            ? descriptor.main\r\n            : function () {};\r\n\r\n        if (typeof main !== 'function') {\r\n            throw new Error('\"main\", if provided has to be a function.');\r\n        }\r\n\r\n        return {\r\n            main: main\r\n        };\r\n    }\r\n\r\n    function Required() {}\r\n\r\n    function isRequired(object) {\r\n        return object instanceof Required;\r\n    }\r\n\r\n    function extractPublicMembers(descriptor) {\r\n        const hasPublicMembers = hasOwnProperty.call(descriptor, 'public');\r\n        const publicMembers = hasPublicMembers\r\n            ? descriptor.public\r\n            : {};\r\n\r\n        if (typeof publicMembers !== 'object') {\r\n            throw new Error('\"public\" has to be an object.');\r\n        }\r\n\r\n        Object_keys(publicMembers).forEach(name => {\r\n            const item = publicMembers[name];\r\n\r\n            if (!isRequired(item) && typeof item !== 'function') {\r\n                throw new Error('\"public\" can only contain functions or ' +\r\n                    ' \"required\" declarations (' +\r\n                    JSON.stringify(publicMembers) + ')');\r\n            }\r\n\r\n            publicMembers[name] = {\r\n                member: item,\r\n                publicName: name,\r\n                privateName: name\r\n            };\r\n        });\r\n\r\n        return {\r\n            publicMembers: publicMembers \r\n        };\r\n    }\r\n\r\n    function extractPrivateMembers(descriptor) {\r\n        const hasPrivateMembers = hasOwnProperty.call(descriptor, 'private');\r\n\r\n        const privateMembers = hasPrivateMembers\r\n            ? descriptor.private\r\n            : {};\r\n\r\n        if (typeof privateMembers !== 'object') {\r\n            throw new Error('\"private\" has to be an object.');\r\n        }\r\n\r\n        Object_keys(privateMembers).forEach(name => {\r\n            if (typeof privateMembers[name] !== 'function') {\r\n                throw new Error('\"private\" can only contain functions (' +\r\n                    JSON.stringify(privateMembers) + ')');\r\n            }\r\n        });\r\n\r\n        return {\r\n            privateMembers: privateMembers\r\n        };\r\n    }\r\n\r\n    // Our expando property being used to store trait meta data\r\n    const expando = '__jeo_trait' + Math.round(Math.random() * 1000000000);\r\n\r\n    // This is a private key for securing our meta data against manipulation\r\n    const secretEvidence = { isTrait: true };\r\n\r\n    function storeMetaData(metaData) {\r\n        return function checkEvidenceValid(givenEvidence) {\r\n            if (givenEvidence === secretEvidence) {\r\n                return metaData;\r\n            }\r\n            else {\r\n                return undefined;\r\n            }\r\n        };\r\n    }\r\n\r\n    function retrieveMetaData(t) {\r\n        if (typeof t[expando] === 'function') {\r\n            return t[expando](secretEvidence);\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    function isTrait(object) {\r\n        if (typeof object[expando] === 'function') {\r\n            return !!retrieveMetaData(object);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function resolveDescriptor(descriptor, resolver) {\r\n        const projection = Object_create(descriptor);\r\n        const result = projection.public = {};\r\n        const publicKeyMap = {};\r\n\r\n        Object_keys(descriptor.public)\r\n            .forEach(name => {\r\n                publicKeyMap[name] = true;\r\n\r\n                const { \r\n                    member, \r\n                    publicName, \r\n                    privateName \r\n                } = descriptor.public[name];\r\n\r\n                const hasRule = hasOwnProperty.call(resolver, name);\r\n                const rule = resolver[name];\r\n                \r\n                if (hasRule) {\r\n                    if (isRequired(member)) {\r\n                        throw new Error('Can not resolve required ' +\r\n                            'member \"' + name + '\".');\r\n                    }\r\n\r\n                    if (rule === null) {\r\n                        if (publicName === null) {\r\n                            // The member is already hidden from the\r\n                            // public api\r\n                            throw new Error('No public member \"' +\r\n                                name + '\" found');\r\n                        }\r\n\r\n                        // Hide\r\n                        result[name] = {\r\n                            member: member,\r\n                            publicName: null,\r\n                            privateName: privateName\r\n                        };\r\n                        return;\r\n                    }\r\n\r\n                    if (typeof rule === 'string') {\r\n                        // Rename\r\n                        result[rule] = {\r\n                            member: member,\r\n                            publicName: rule,\r\n                            privateName: privateName\r\n                        };\r\n                        return;\r\n                    }\r\n                }\r\n                else {\r\n                    // Copy\r\n                    result[name] = {\r\n                        member: member,\r\n                        publicName: publicName,\r\n                        privateName: privateName\r\n                    };\r\n                }\r\n            });\r\n\r\n        Object_keys(resolver).forEach(name => {\r\n            if (!hasOwnProperty.call(publicKeyMap, name)) {\r\n                throw new Error('\"' + name + '\" can not be resolved ' +\r\n                    'because it is not a public method on ' + \r\n                    JSON.stringify(descriptor));\r\n            }\r\n        });\r\n\r\n        return projection;\r\n    }\r\n\r\n    function makeTrait(descriptor) {\r\n\r\n        const t = {\r\n            resolve(resolver) {\r\n                return makeTrait(resolveDescriptor(descriptor, resolver));\r\n            }\r\n        };\r\n        t.create = createToplevelInstanceFactory(t);\r\n        t[expando] = storeMetaData(descriptor);\r\n\r\n        return Object_freeze(t);\r\n    }\r\n\r\n    function makeHash(t) {\r\n        const publicMembers = retrieveMetaData(t).public;\r\n        let hash = Object_keys(publicMembers)\r\n            .map(name => publicMembers[name].publicName)\r\n            .filter(m => m !== null);\r\n        hash.sort();\r\n        return hash.join('#');\r\n    }\r\n\r\n    function closeOverInstance(instance, config) {\r\n        return function applyStatefulTrait(t) {\r\n            let [substitute] = config.for.filter(tt => tt.trait === t);\r\n            if (substitute) {\r\n                let substituteHash = makeHash(substitute.use);\r\n                let hashOfT = makeHash(t);\r\n\r\n                if (hashOfT !== substituteHash) {\r\n                    throw new Error('Substiute hash \"' + substituteHash + \r\n                        '\" does not match the hash \"' + hashOfT + '\" of ' +\r\n                        'the trait to be substituted');\r\n                }\r\n                t = substitute.use;\r\n            }\r\n\r\n            const descriptor = retrieveMetaData(t);\r\n            const publicMembers = descriptor.public;\r\n            const privateMembers = descriptor.private;\r\n            const dependencies = descriptor.requires\r\n                .map(dep => createInstance(dep, config));\r\n\r\n            const privateContext = {};\r\n            \r\n            descriptor.constructor.apply(privateContext, dependencies);\r\n\r\n            Object_keys(privateMembers)\r\n                .forEach(name => {\r\n                    const member = privateMembers[name];\r\n\r\n                    if (isRequired(member)) {\r\n                        throw new Error('Private members can not be ' +\r\n                            'required');\r\n                    }\r\n\r\n                    if (hasOwnProperty.call(privateContext, name)) {\r\n                        throw new Error('Can not overwrite member \"' +\r\n                            name + '\" which has previously been defined');\r\n                    }\r\n\r\n                    privateContext[name] = function () {\r\n                        return member.apply(privateContext, arguments);\r\n                    };\r\n                });\r\n\r\n            Object_keys(publicMembers)\r\n                .forEach(name => {\r\n                    const { \r\n                        member, \r\n                        publicName,\r\n                        privateName\r\n                    } = publicMembers[name];\r\n\r\n                    if (hasOwnProperty.call(privateContext, privateName)) {\r\n                        throw new Error('Can not overwrite member \"' +\r\n                            name + '\" which has previously been defined');\r\n                    }\r\n\r\n                    const memberIsRequired = isRequired(member);\r\n                    const fn = function () {\r\n                        return member.apply(privateContext, arguments);\r\n                    };\r\n\r\n                    const instanceHasMemberWithSameName = \r\n                        hasOwnProperty.call(instance, publicName);\r\n\r\n                    const instanceMemberWithSameNameIsRequired =\r\n                        instanceHasMemberWithSameName &&\r\n                            isRequired(instance[publicName]);\r\n\r\n                    const instanceMemberWithSameNameIsImplementation =\r\n                        instanceHasMemberWithSameName &&\r\n                            !isRequired(instance[publicName]);\r\n\r\n                    if (memberIsRequired && \r\n                        instanceMemberWithSameNameIsRequired) {\r\n                        // Do nothing, both are required so we\r\n                        // wait for an actual implementation\r\n                    }\r\n                    else if (memberIsRequired &&\r\n                            instanceMemberWithSameNameIsImplementation) {\r\n                        // Do nothing, the implementation is already\r\n                        // attached to the instance\r\n                    }\r\n                    else if (memberIsRequired && \r\n                            !instanceHasMemberWithSameName) {\r\n                        // This declares a new required member and\r\n                        // we still wait for the implementation\r\n                        instance[publicName] = member;\r\n                    }\r\n                    else if (!memberIsRequired &&\r\n                            (instanceMemberWithSameNameIsRequired ||\r\n                             !instanceHasMemberWithSameName)) {\r\n                        // Overwrite the required statement with the\r\n                        // specified implementation\r\n                        privateContext[privateName] = fn;\r\n\r\n                        if (publicName !== null) {\r\n                            instance[publicName] = fn;\r\n                        }\r\n                    }\r\n                    else {\r\n                        throw new Error('Unknown composition pattern');\r\n                    }\r\n                });\r\n        };\r\n    }\r\n\r\n    function createInstance(t, config) {\r\n        if (!isTrait(t)) {\r\n            throw new Error('The argument \"' + JSON.stringify(t) + '\" is ' +\r\n                'not a trait and therefore can not be instantiated.');\r\n        }\r\n\r\n        const descriptor = retrieveMetaData(t);\r\n        let instance = {};\r\n        let traits = [t].concat(descriptor.is);\r\n\r\n        const applyStatefulTrait = closeOverInstance(instance, config);\r\n        traits.forEach(applyStatefulTrait);\r\n\r\n        Object_keys(instance).forEach(name => {\r\n            const member = instance[name];\r\n\r\n            if (isRequired(member)) {\r\n                throw new Error('Can not instantiate incomplete ' +\r\n                    'trait. The member \"' + name + \r\n                    '\" is still required.');\r\n            }\r\n        });\r\n\r\n        return instance;\r\n    }\r\n\r\n    // The main entry point for our library\r\n    function trait(descriptor) {\r\n        if (arguments.length > 1) {\r\n            const args = [].slice.call(arguments).map(arg => {\r\n                if (!arg) {\r\n                    throw new Error('A top level argument can not be falsy');\r\n                }\r\n\r\n                if (!isTrait(arg)) {\r\n                    return trait({ public: arg });\r\n                }\r\n                else {\r\n                    return arg;\r\n                }\r\n            });\r\n            return trait({ is: args });\r\n        }\r\n\r\n        if (typeof descriptor === 'function') {\r\n            descriptor = descriptor(createInstance(trait.Util, trait.config));\r\n        }\r\n\r\n        let { constructor, requires } = extractDependencies(descriptor);\r\n        let { traits } = extractTraits(descriptor);\r\n        let { main } = extractMain(descriptor);\r\n        let { publicMembers } = extractPublicMembers(descriptor);\r\n        let { privateMembers } = extractPrivateMembers(descriptor);\r\n\r\n        return makeTrait({\r\n            is: traits,\r\n            requires: requires,\r\n            constructor: constructor,\r\n            main: main,\r\n            public: publicMembers,\r\n            private: privateMembers\r\n        });\r\n    }\r\n\r\n    function createToplevelInstanceFactory(t) {\r\n        return function createToplevelInstance(config = {}) {\r\n            const currentConfig = mix(trait.config, config);\r\n\r\n            currentConfig.for.forEach(item => {\r\n                if (!isTrait(item.trait)) {\r\n                    throw new Error('Invalid configured dependency');\r\n                }\r\n                if (!isTrait(item.use)) {\r\n                    throw new Error('Invalid substituted dependency ' +\r\n                        'configured');\r\n                }\r\n            });\r\n\r\n            return createInstance(t, currentConfig);\r\n        };\r\n    }\r\n\r\n    return {\r\n        trait: Object_freeze(mix(trait, {\r\n            Util: trait({\r\n                public: {\r\n                    assert: assert,\r\n                    log() { console.log(...arguments); },\r\n                    mix: mix,\r\n                    requires: requires\r\n                }\r\n            }),\r\n            config: { for: [] },\r\n            isTrait: isTrait,\r\n            required: Object_freeze(new Required())\r\n        }))\r\n    };\r\n}));\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"sourceRoot":"/source/"}